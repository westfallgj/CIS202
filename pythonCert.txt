Key takeaways

1. The print() function is a built-in function. It prints/outputs a specified message to the screen/console window.
 
2. Built-in functions, contrary to user-defined functions, are always available and don't have to be imported. 
Python 3.8 comes with 69 built-in functions. You can find their full list provided in alphabetical order in the 
Python Standard Library.

3. To call a function (this process is known as function invocation or function call), you need to use the function name followed by parentheses. You can pass arguments into a function by placing them inside the parentheses. You must separate arguments with a comma, e.g., print("Hello,", "world!"). An "empty" print() function outputs an empty line to the screen.

4. Python strings are delimited with quotes, e.g., "I am a string" (double quotes), or 'I am a string, too' (single quotes).

5. Computer programs are collections of instructions. An instruction is a command to perform a specific task when executed, e.g., to print a certain message to the screen.

6. In Python strings the backslash (\) is a special character which announces that the next character has a different meaning, e.g., \n (the newline character) starts a new output line.

7. Positional arguments are the ones whose meaning is dictated by their position, e.g., the second argument is outputted after the first, the third is outputted after the second, etc.

8. Keyword arguments are the ones whose meaning is not dictated by their location, but by a special word (keyword) used to identify them.

9. The end and sep parameters can be used for formatting the output of the print() function. The sep parameter specifies the separator between the outputted arguments, e.g., print("H", "E", "L", "L", "O", sep="-"), whereas the end parameter specifies what to print at the end of the print statement.

Key takeaways
1. Literals are notations for representing some fixed values in code. Python has various types of literals - for example, a literal can be a number (numeric literals, e.g., 123), or a string (string literals, e.g., "I am a literal.").

2. The binary system is a system of numbers that employs 2 as the base. Therefore, a binary number is made up of 0s and 1s only, e.g., 1010 is 10 in decimal.

Octal and hexadecimal numeration systems, similarly, employ 8 and 16 as their bases respectively. The hexadecimal system uses the decimal numbers and six extra letters.
3. Integers (or simply ints) are one of the numerical types supported by Python. They are numbers written without a fractional component, e.g., 256, or -1 (negative integers).

4. Floating-point numbers (or simply floats) are another one of the numerical types supported by Python. They are numbers that contain (or are able to contain) a fractional component, e.g., 1.27.

5. To encode an apostrophe or a quote inside a string you can either use the escape character, e.g., 'I\'m happy.', or open and close the string using an opposite set of symbols to the ones you wish to encode, e.g., "I'm happy." to encode an apostrophe, and 'He said "Python", not "typhoon"' to encode a (double) quote.

6. Boolean values are the two constant objects True and False used to represent truth values (in numeric contexts 1 is True, while 0 is False.

EXTRA

There is one more, special literal that is used in Python: the None literal. This literal is a so-called NoneType object, and it is used to represent the absence of a value. We'll tell you more about it soon.



Exercise 1

What types of literals are the following two examples?

"Hello ", "007"

Check
They're both strings/string literals.


Exercise 2

What types of literals are the following four examples?

"1.5", 2.0, 528, False

Check
The first is a string, the second is a numerical literal (a float), the third is a numerical literal (an integer), and the fourth is a boolean literal.


Exercise 3

What is the decimal value of the following binary number?

1011

Check
It's 11, because (2**0) + (2**1) + (2**3) = 11

Key takeaways
1. An expression is a combination of values (or variables, operators, calls to functions ‒ you will learn about them soon) which evaluates to a certain value, e.g., 1 + 2.

2. Operators are special symbols or keywords which are able to operate on the values and perform (mathematical) operations, e.g., the * operator multiplies two values: x * y.

3. Arithmetic operators in Python: + (addition), - (subtraction), * (multiplication), / (classic division ‒ always returns a float), % (modulus ‒ divides left operand by right operand and returns the remainder of the operation, e.g., 5 % 2 = 1), ** (exponentiation ‒ left operand raised to the power of right operand, e.g., 2 ** 3 = 2 * 2 * 2 = 8), // (floor/integer division ‒ returns a number resulting from division, but rounded down to the nearest whole number, e.g., 3 // 2.0 = 1.0)

4. A unary operator is an operator with only one operand, e.g., -1, or +3.

5. A binary operator is an operator with two operands, e.g., 4 + 5, or 12 % 5.

6. Some operators act before others – the hierarchy of priorities:

the ** operator (exponentiation) has the highest priority;
then the unary + and - (note: a unary operator to the right of the exponentiation operator binds more strongly, for example: 4 ** -1 equals 0.25)
then *, /, //, and %;
and, finally, the lowest priority: the binary + and -.
7. Subexpressions in parentheses are always calculated first, e.g., 15 - 1 * (5 * (1 + 2)) = 0.

8. The exponentiation operator uses right-sided binding, e.g., 2 ** 2 ** 3 = 256.




Exercise 1

What is the output of the following snippet?

print((2 ** 4), (2 * 4.), (2 * 4))


Check
16 8.0 8


Exercise 2

What is the output of the following snippet?

print((-2 / 4), (2 / 4), (2 // 4), (-2 // 4))


Check
-0.5 0.5 0 -1


Exercise 3

What is the output of the following snippet?

print((2 % -4), (2 % 4), (2 ** 3 ** 2))


Check
-2 2 512


Key takeaways

1. A variable is a named location reserved to store values in the memory. A variable is created or initialized automatically when you assign a value to it for the first time. (2.1.4.1)

2. Each variable must have a unique name - an identifier. A legal identifier name must be a non-empty sequence of characters, must begin with the underscore(_), or a letter, and it cannot be a Python keyword. The first character may be followed by underscores, letters, and digits. Identifiers in Python are case-sensitive. (2.1.4.1)

3. Python is a dynamically-typed language, which means you don't need to declare variables in it. (2.1.4.3) To assign values to variables, you can use a simple assignment operator in the form of the equal (=) sign, i.e., var = 1.

4. You can also use compound assignment operators (shortcut operators) to modify values assigned to variables, e.g., var += 1, or var /= 5 * 2. (2.1.4.8)

5. You can assign new values to already existing variables using the assignment operator or one of the compound operators, e.g.: (2.1.4.5)

var = 2
print(var)

var = 3
print(var)

var += 1
print(var)


6. You can combine text and variables using the + operator, and use the print() function to output strings and variables, e.g.: (2.1.4.4)

var = "007"
print("Agent " + var)





Exercise 1

What is the output of the following snippet?

var = 2
var = 3
print(var)


Check
3


Exercise 2

Which of the following variable names are illegal in Python?

my_var
m
101
averylongvariablename
m101
m 101
Del
del

Check
my_var
m
101 # incorrect (starts with a digit)
averylongvariablename
m101
m 101 # incorrect (contains a space)
Del
del # incorrect (is a keyword)


Exercise 3

What is the output of the following snippet?

a = '1'
b = "1"
print(a + b)


Check
11


Exercise 4

What is the output of the following snippet?

a = 6
b = 3
a /= 2 * b
print(a)


Check
1.0

2 * b = 6
a = 6 → 6 / 6 = 1.0


Key takeaways

1. Comments can be used to leave additional information in code. They are omitted at runtime. The information left in source code is addressed to human readers. In Python, a comment is a piece of text that begins with #. The comment extends to the end of line.

2. If you want to place a comment that spans several lines, you need to place # in front of them all. Moreover, you can use a comment to mark a piece of code that is not needed at the moment (see the last line of the snippet below), e.g.:

# This program prints
# an introduction to the screen.
print("Hello!")  # Invoking the print() function
# print("I'm Python.")


3. Whenever possible and justified, you should give self-commenting names to variables, e.g., if you're using two variables to store a length and width of something, the variable names length and width may be a better choice than myvar1 and myvar2.

4. It's important to use comments to make programs easier to understand, and to use readable and meaningful variable names in code. However, it's equally important not to use variable names that are confusing, or leave comments that contain wrong or incorrect information!

5. Comments can be important when you are reading your own code after some time (trust us, developers do forget what their own code does), and when others are reading your code (can help them understand what your programs do and how they do it more quickly).




Exercise 1

What is the output of the following snippet?

# print("String #1")
print("String #2")


Check
String #2


Exercise 2

What will happen when you run the following code?

# This is
a multiline
comment. #

print("Hello!")


Check
SyntaxError: invalid syntax

Key takeaways

1. The print() function sends data to the console, while the input() function gets data from the console.

2. The input() function comes with an optional parameter: the prompt string. It allows you to write a message before the user input, e.g.:

name = input("Enter your name: ")
print("Hello, " + name + ". Nice to meet you!")


3. When the input() function is called, the program's flow is stopped, the prompt symbol keeps blinking (it prompts the user to take action when the console is switched to input mode) until the user has entered an input and/or pressed the Enter key.

NOTE

You can test the functionality of the input() function in its full scope locally on your machine. For resource optimization reasons, we have limited the maximum program execution time in Edube to a few seconds. Go to the Sandbox, copy-paste the above snippet, run the program, and do nothing ‒ just wait a few seconds to see what happens. Your program should be stopped automatically after a short moment. Now open IDLE, and run the same program there ‒ can you see the difference?

Tip: the above-mentioned feature of the input() function can be used to prompt the user to end a program. Look at the code below:

name = input("Enter your name: ")
print("Hello, " + name + ". Nice to meet you!")

print("\nPress Enter to end the program.")
input()
print("THE END.")


4. The result of the input() function is a string. You can add strings to each other using the concatenation (+) operator. Check out this code:

num_1 = input("Enter the first number: ") # Enter 12
num_2 = input("Enter the second number: ") # Enter 21

print(num_1 + num_2) # the program returns 1221


5. You can also multiply (* ‒ replication) strings, e.g.:

my_input = input("Enter something: ") # Example input: hello
print(my_input * 3) # Expected output: hellohellohello





Exercise 1

What is the output of the following snippet?

x = int(input("Enter a number: ")) # The user enters 2
print(x * "5")


Check
55


Exercise 2

What is the expected output of the following snippet?

x = input("Enter a number: ") # The user enters 2
print(type(x))


Check
<class 'str'>

Key takeaways

1. The comparison (otherwise known as relational) operators are used to compare values. The table below illustrates how the comparison operators work, assuming that x = 0, y = 1, and z = 0:

Operator	Description	Example
==	returns True if operands' values are equal, and False otherwise	
!=	returns True if operands' values are not equal, and False otherwise	
x != y  # True
x != z  # False

>	True if the left operand's value is greater than the right operand's value, and False otherwise	
x > y  # False
y > z  # True

<	True if the left operand's value is less than the right operand's value, and False otherwise	
x < y  # True
y < z  # False

≥	True if the left operand's value is greater than or equal to the right operand's value, and False otherwise	
x >= y  # False
x >= z  # True
y >= z  # True

≤	True if the left operand's value is less than or equal to the right operand's value, and False otherwise	
x <= y  # True
x <= z  # True
y <= z  # False

2. When you want to execute some code only if a certain condition is met, you can use a conditional statement:

a single if statement, e.g.:

x = 10

if x == 10: # condition
    print("x is equal to 10")  # Executed if the condition is True.


a series of if statements, e.g.:

x = 10

if x > 5: # condition one
    print("x is greater than 5")  # Executed if condition one is True.

if x < 10: # condition two
    print("x is less than 10")  # Executed if condition two is True.

if x == 10: # condition three
    print("x is equal to 10")  # Executed if condition three is True.
    

Each if statement is tested separately.




an if-else statement, e.g.:

x = 10

if x < 10:  # Condition
    print("x is less than 10")  # Executed if the condition is True.

else:
    print("x is greater than or equal to 10")  # Executed if the condition is False.


a series of if statements followed by an else, e.g.:

x = 10

if x > 5:  # True
    print("x > 5")

if x > 8:  # True
    print("x > 8")

if x > 10:  # False
    print("x > 10")

else:
    print("else will be executed")


Each if is tested separately. The body of else is executed if the last if is False.

The if-elif-else statement, e.g.:

x = 10

if x == 10:  # True
    print("x == 10")

if x > 15:  # False
    print("x > 15")

elif x > 10:  # False
    print("x > 10")

elif x > 5:  # True
    print("x > 5")

else:
    print("else will not be executed")


If the condition for if is False, the program checks the conditions of the subsequent elif blocks – the first elif block that is True is executed. If all the conditions are False, the else block will be executed.

Nested conditional statements, e.g.:

x = 10

if x > 5:  # True
    if x == 6:  # False
        print("nested: x == 6")
    elif x == 10:  # True
        print("nested: x == 10")
    else:
        print("nested: else")
else:
    print("else")

Key takeaways

1. There are two types of loops in Python: while and for:

the while loop executes a statement or a set of statements as long as a specified boolean condition is true, e.g.:

# Example 1
while True:
    print("Stuck in an infinite loop.")

# Example 2
counter = 5
while counter > 2:
    print(counter)
    counter -= 1


the for loop executes a set of statements many times; it's used to iterate over a sequence (e.g., a list, a dictionary, a tuple, or a set - you will learn about them soon) or other objects that are iterable (e.g., strings). You can use the for loop to iterate over a sequence of numbers using the built-in range function. Look at the examples below:

# Example 1
word = "Python"
for letter in word:
    print(letter, end="*")

# Example 2
for i in range(1, 10):
    if i % 2 == 0:
        print(i)


2. You can use the break and continue statements to change the flow of a loop:

You use break to exit a loop, e.g.:

text = "OpenEDG Python Institute"
for letter in text:
    if letter == "P":
        break
    print(letter, end="")


You use continue to skip the current iteration, and continue with the next iteration, e.g.:

text = "pyxpyxpyx"
for letter in text:
    if letter == "x":
        continue
    print(letter, end="")





3. The while and for loops can also have an else clause in Python. The else clause executes after the loop finishes its execution as long as it has not been terminated by break, e.g.:

n = 0

while n != 3:
    print(n)
    n += 1
else:
    print(n, "else")

print()

for i in range(0, 3):
    print(i)
else:
    print(i, "else")


4. The range() function generates a sequence of numbers. It accepts integers and returns range objects. The syntax of range() looks as follows: range(start, stop, step), where:


start is an optional parameter specifying the starting number of the sequence (0 by default)
stop is an optional parameter specifying the end of the sequence generated (it is not included),
and step is an optional parameter specifying the difference between the numbers in the sequence (1 by default.)
Example code:

for i in range(3):
    print(i, end=" ")  # Outputs: 0 1 2

for i in range(6, 1, -2):
    print(i, end=" ")  # Outputs: 6, 4, 2

Key takeaways: continued
Exercise 1

Create a for loop that counts from 0 to 10, and prints odd numbers to the screen. Use the skeleton below:

for i in range(1, 11):
    # Line of code.
        # Line of code.


Check
Sample solution:
for i in range(0, 11):
    if i % 2 != 0:
        print(i)



Exercise 2

Create a while loop that counts from 0 to 10, and prints odd numbers to the screen. Use the skeleton below:

x = 1
while x < 11:
    # Line of code.
        # Line of code.
    # Line of code.


Check
Sample solution:
x = 1
while x < 11:
    if x % 2 != 0:
        print(x)
    x += 1



Exercise 3

Create a program with a for loop and a break statement. The program should iterate over characters in an email address, exit the loop when it reaches the @ symbol, and print the part before @ on one line. Use the skeleton below:

for ch in "john.smith@pythoninstitute.org":
    if ch == "@":
        # Line of code.
    # Line of code.


Check
Sample solution:
for ch in "john.smith@pythoninstitute.org":
    if ch == "@":
        break
    print(ch, end="")



Exercise 4

Create a program with a for loop and a continue statement. The program should iterate over a string of digits, replace each 0 with x, and print the modified string to the screen. Use the skeleton below:

for digit in "0165031806510":
    if digit == "0":
        # Line of code.
        # Line of code.
    # Line of code.


Check
Sample solution:
for digit in "0165031806510":
    if digit == "0":
        print("x", end="")
        continue
    print(digit, end="")





Exercise 5

What is the output of the following code?

n = 3

while n > 0:
    print(n + 1)
    n -= 1
else:
    print(n)


Check
4
3
2
0


Exercise 6

What is the output of the following code?

n = range(4)

for num in n:
    print(num - 1)
else:
    print(num)


Check
-1
0
1
2
3

Exercise 7

What is the output of the following code?

for i in range(0, 6, 3):
    print(i)


Check
0
3


