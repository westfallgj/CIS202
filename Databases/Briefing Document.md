# Python SQLite Database Programming Fundamentals [1]

#### Briefing Document: Database Programming with Python (SQLite) [1]
**Source:** Excerpts from "14_Gaddis Python_Lecture_ppt_ch14" [1]
**Date:** October 26, 2023 [1]
**Overview:** This document provides a briefing on the fundamental concepts of database programming using Python, specifically focusing on the SQLite database management system [1]. The information is derived from Chapter 14 of "Starting out with Python," Fifth Edition [1]. This chapter covers topics ranging from the basics of database management systems and SQL to performing CRUD operations and working with relational data in SQLite [1].

## Key Themes and Important Ideas/Facts: [2]

### 1. Database Management Systems (DBMS): [2]
*   Storing data in traditional files has limitations, especially for large amounts of data where operations become cumbersome and inefficient [2].
*   A **Database Management System (DBMS)** is defined as "software that is specifically designed to work with large amounts of data in an efficient and organized manner" [2].
*   Python applications communicate with the DBMS (like SQLite) to store and retrieve data, rather than directly manipulating data files [2]. The DBMS handles the underlying data management [2].
*   The interaction involves the application sending commands (typically SQL statements) to the DBMS, which then executes them on the data and sends the results back to the application [2].

### 2. SQL (Structured Query Language): [3]
*   SQL is "**a standard language for working with database management systems**" [3].
*   It is not a general-purpose programming language but consists of keywords used to construct statements that instruct the DBMS [3].
*   SQL statements are passed as strings from the Python application to the DBMS using API method calls [3].

### 3. SQLite: [3]
*   This chapter focuses on the SQLite DBMS, which is "**automatically installed with Python in a module named sqlite3**" [3].
*   It is presented as easy to use [3].
*   To use SQLite in Python, you need to "**Use this import statement: import sqlite3**" [3].

### 4. Tables, Rows, and Columns: [4]
*   A database is organized into one or more **tables** [4].
*   Each **table** holds a collection of related data organized into **rows** and **columns** [4].
*   A **row** represents "**a complete set of data about a single item, divided into columns**" [4].
*   Each **column** represents "**an individual piece of data about the item**" [4].

### 5. Column Data Types: [4]
*   SQLite supports various data types for columns, including: [4]
    *   NULL: Unknown value (corresponds to `None` in Python) [4].
    *   INTEGER: Integer number (corresponds to `int` in Python) [4].
    *   REAL: Real number (corresponds to `float` in Python) [4].
    *   TEXT: String (corresponds to `str` in Python) [4].
    *   BLOB: Binary Large Object (can be any object in Python) [4].

### 6. Primary Keys: [5]
*   A **primary key** is "**a column that holds a unique value for each row in a database table**" [5].
*   It is used to "**identify a specific row**" [5].
*   Example: An employee ID number in an employee data table [5].
*   An **identity column** contains unique values generated by the DBMS, typically autoincremented integers [5]. This can be used as a primary key when no other column naturally contains unique values [5].
*   A primary key "**can never be null**" [5]. A `NOT NULL` constraint can be applied to prevent null values in a column [5].

### 7. Database Connections with SQLite: [6]
*   The typical process involves: [6]
    1.  **Connect to the database** (`sqlite3.connect('database_name')`) [6]. This creates the database file if it doesn't exist [6]. The `connect` method returns a `Connection` object [6].
    2.  **Get a cursor for the database** (`conn.cursor()`) [6]. The `cursor` method returns a `Cursor` object, which allows you to perform operations [6].
    3.  **Perform operations on the database** using the cursor (e.g., execute SQL statements) [6].
    4.  **Commit changes to the database** (`conn.commit()`) [6]. This saves the changes [6].
    5.  **Close the connection to the database** (`conn.close()`) [6]. This releases resources [6].

### 8. Creating and Deleting Tables: [7]
*   The SQL statement `CREATE TABLE` is used to add a table [7].
    *   General format: `CREATE TABLE TableName (ColumnName1 DataType1, ColumnName2 DataType2, ...)` [7]
    *   Example: `CREATE TABLE Inventory (ItemName TEXT, Price REAL)` [7]
*   To designate a column as the primary key, use the `PRIMARY KEY` constraint after the data type [7].
    *   Example: `CREATE TABLE Inventory (ItemID INTEGER PRIMARY KEY, ItemName TEXT, Price REAL)` [7]
    *   In SQLite, an `INTEGER PRIMARY KEY` column automatically becomes an autoincremented identity column [7].
*   The `NOT NULL` constraint ensures a column cannot be left empty [7].
    *   Example: `CREATE TABLE Inventory (ItemID INTEGER PRIMARY KEY NOT NULL, ItemName TEXT, Price REAL)` [7]
*   You can create a table only if it doesn't already exist using `CREATE TABLE IF NOT EXISTS TableName (...)` [7].
*   The SQL statement `DROP TABLE TableName` deletes a table [7]. Use `DROP TABLE IF EXISTS TableName` to avoid errors if the table doesn't exist [7].

### 9. Adding Data to a Table: [8]
*   The SQL statement `INSERT INTO` is used to add new rows to a table [8].
    *   General format: `INSERT INTO TableName (ColumnName1, ColumnName2, ...) VALUES (Value1, Value2, ...)` [8]
    *   Example: `INSERT INTO Inventory (ItemID, ItemName, Price) VALUES (1, "Paint Brush", 8.99)` [8]
*   If you omit the value for an `INTEGER PRIMARY KEY` column, SQLite will provide an auto-generated value [8].
    *   Example: `INSERT INTO Inventory (ItemName, Price) VALUES ("Paint Brush", 8.99)` (assuming `ItemID` is an `INTEGER PRIMARY KEY`) [8].
*   Multiple rows can be inserted with separate `INSERT` statements or with a single `INSERT` statement with multiple sets of values [8].
*   Values from Python variables can be inserted using question-mark placeholders and passing the values as a tuple to the `execute()` method [8].
    *   Example:
        ```python
        cur.execute('''INSERT INTO Inventory (ItemName, Price) VALUES (?, ?)''', (item_name, price))
        ```
        [8]

### 10. Querying Data with the SQL SELECT Statement: [9]
*   The `SELECT` statement is used to "**retrieve specified rows from a table**" [9].
    *   General format: `SELECT Columns FROM Table` [9]
    *   `Columns` can be one or more column names (separated by commas) or `*` to select all columns [9].
    *   `Table` is the name of the table to retrieve data from [9].
*   In Python with SQLite, querying involves: [9]
    1.  Executing the `SELECT` statement using the cursor's `execute()` method [9].
    2.  Fetching the results using methods like `fetchall()` (returns a list of all matching rows as tuples) or `fetchone()` (returns the next single matching row as a tuple, or `None` if no more rows) [9].

### 11. Specifying Search Criteria with the WHERE Clause: [10]
*   The `WHERE` clause is used with the `SELECT` statement to "**specify search criteria**" [10]. Only rows that meet the criteria are returned [10].
    *   General format: `SELECT Columns FROM Table WHERE Criteria` [10]
    *   `Criteria` is a conditional expression using column names, values, and operators [10].
*   SQL Relational Operators include: `>`, `<`, `>=`, `<=`, `=`, `==`, `!=`, `<>` [10].
*   SQL Logical Operators include: `AND`, `OR`, `NOT` [10].
*   The `LIKE` operator is used for pattern matching in strings, with `%` as a wildcard for multiple characters [10].
    *   Example: `WHERE Description LIKE "%Bar%"` (finds descriptions containing "Bar") [10].

### 12. Sorting Query Results with the ORDER BY Clause: [11]
*   The `ORDER BY` clause sorts the results of a `SELECT` query based on one or more columns [11].
    *   Example: `SELECT * FROM Products ORDER BY RetailPrice` (sorts by `RetailPrice` in ascending order by default) [11].

### 13. Aggregate Functions: [11]
*   SQL provides aggregate functions to perform calculations on sets of rows [11]:
    *   `AVG(Column)`: Calculates the average value [11].
    *   `SUM(Column)`: Calculates the sum of values [11].
    *   `MIN(Column)`: Finds the minimum value [11].
    *   `MAX(Column)`: Finds the maximum value [11].
    *   `COUNT(*)`: Counts the number of rows [11].
    *   `COUNT(Column)`: Counts the number of non-null values in a column [11].

### 14. Updating Rows with the UPDATE Statement: [12]
*   The `UPDATE` statement "**changes the contents of an existing row in a table**" [12].
    *   General format: `UPDATE Table SET Column = Value WHERE Criteria` [12]
    *   `Table`: Name of the table to update [12].
    *   `Column`: Name of the column to modify [12].
    *   `Value`: The new value for the column [12].
    *   `Criteria` (optional): A `WHERE` clause to specify which rows to update [12].
*   Multiple columns can be updated in a single `UPDATE` statement by separating the assignments with commas [12].
*   **Warning:** Omitting the `WHERE` clause will update every row in the table [12].
*   The `Cursor` object's `rowcount` attribute can be used after `execute()` and `commit()` to determine the number of rows updated [12].

### 15. Deleting Rows with the DELETE Statement: [13]
*   The `DELETE FROM` statement "**deletes one or more rows**" from a table [13].
    *   General format: `DELETE FROM Table WHERE Criteria` [13]
    *   `Table`: Name of the table [13].
    *   `Criteria` (optional): A `WHERE` clause to specify which rows to delete [13].
*   **Warning:** Omitting the `WHERE` clause will delete every row in the table [13].
*   The `Cursor` object's `rowcount` attribute can be used after `execute()` and `commit()` to determine the number of rows deleted [13].

### 16. More About Primary Keys: [13]
*   Primary keys must hold a value (cannot be `NULL`) [13].
*   Each row's primary key value must be unique within the table [13].
*   A table can have only one primary key, but it can be a **composite key** consisting of two or more columns combined to ensure uniqueness [13].
*   In SQLite, tables automatically have an `INTEGER` column named `rowid` which is auto incremented [13]. When you define an `INTEGER PRIMARY KEY` column, it becomes an alias for the `rowid` column [13].
*   You can designate any data type of column as a primary key, but be sure to use the `NOT NULL` constraint [13]. For non-integer primary keys, you must provide a unique, non-null value when inserting rows [13].

### 17. Handling Database Exceptions in SQLite: [14]
*   The `sqlite3` module defines an exception named `Error` that is raised when a database error occurs [14].
*   It is good practice to write database code within a `try`/`except` statement to catch potential exceptions [14].
*   You can specifically catch `sqlite3.Error` for database-related issues and a general `Exception` for other errors [14].
*   A `finally` block can be used to ensure the database connection is closed, even if an error occurs [14].

### 18. CRUD Operations: [14]
*   **CRUD** stands for the four basic operations that a database application typically performs [14]:
    *   **Create:** Creating new data (achieved with `INSERT`) [14].
    *   **Read:** Reading existing data (achieved with `SELECT`) [14].
    *   **Update:** Changing existing data (achieved with `UPDATE`) [14].
    *   **Delete:** Removing existing data (achieved with `DELETE`) [14].

### 19. Relational Data: [15]
*   In a relational database, "**a column from one table can be associated with a column from other tables**" [15].
*   Relational design can reduce data duplication, which can lead to wasted storage and inconsistent data [15].
*   Data is often separated into multiple tables to represent different entities and their attributes [15].

### 20. Foreign Keys: [15]
*   A **foreign key** is "**a column in one table that references a primary key in another table**" [15].
*   Foreign keys establish relationships between tables [15].
*   When a row is added to a table with a foreign key, the value in the foreign key column must match a value in the primary key column of the referenced table [15]. This ensures **referential integrity** [15].
*   In SQL, foreign keys are defined using the `FOREIGN KEY` constraint with the `REFERENCES` clause [15].
    *   Example: `FOREIGN KEY (DepartmentID) REFERENCES Departments(DepartmentID)` [15]
*   SQLite, by default, does not enforce foreign key integrity [15]. You need to enable it for each connection using `cur.execute('PRAGMA foreign_keys=ON')` [15].
*   When working with relational data and foreign keys, remember: [15]
    *   New foreign key values must reference existing primary key values [15].
    *   Updating a foreign key to an invalid value is not allowed [15].
    *   You cannot delete a row in a referenced table if it is currently being referenced by a foreign key in another table (unless specific constraints like `ON DELETE CASCADE` are in place, which are not discussed in detail here) [15].

### 21. Entity Relationship Diagrams: [16]
*   Entity Relationship Diagrams (ERDs) are used to visually represent the structure of a relational database, including tables and their relationships [16].
*   Notation like 1 and âˆž indicates the cardinality of relationships (e.g., one-to-many) [16].

### 22. Retrieving Columns from Multiple Tables in a SELECT Statement: [16]
*   To retrieve data from multiple tables in a single `SELECT` statement, you need to specify the tables in the `FROM` clause (separated by commas) and use fully qualified column names (e.g., `TableName.ColumnName`) if there are columns with the same name in different tables [16].
*   A `WHERE` clause is typically used to specify how the tables are related (joining conditions), often by comparing primary and foreign key columns [16].

## Summary: [17]
This chapter provides a foundational understanding of database programming with Python and SQLite [17]. It covers the motivation for using DBMS, the basics of SQL, how to interact with SQLite from Python, the structure of databases (tables, rows, columns), data types, primary and foreign keys, essential SQL commands for creating, reading, updating, and deleting data, handling database exceptions, and the principles of relational data [17]. Understanding these concepts is crucial for developing Python applications that need to persistently store and manage data [17].
